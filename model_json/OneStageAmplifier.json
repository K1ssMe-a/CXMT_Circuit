{
    "model_name": "OneStageAmplifier",
    "model_description": "One Stage Source-Common Amplifier with Resistor Load",
    "inputnode": "Vin (input signal), Vbias (bias voltage for setting operating point), VDD (drain power supply voltage), GND (ground connection)",
    "outputnode": "Vout (amplified output signal)",
    "parameter": null,
    "parameter_description": "- nmos_width: Channel width of the NMOS transistor. Increasing this value raises the transconductance and gain but also increases parasitic capacitances.\n- nmos_length: Channel length of the NMOS transistor. Longer channels reduce short-channel effects but decrease transconductance and gain.\n- load_resistance: Value of the load resistor. Higher values increase voltage gain but reduce bandwidth and output swing.\n- input_capacitance: Input coupling capacitor value. Blocks DC while allowing AC signals to pass; larger values extend low-frequency response.\n- output_capacitance: Output coupling capacitor value. Blocks DC while allowing AC signals to pass; larger values extend low-frequency response.",
    "netlist": "from PySpice.Unit import *\nfrom PySpice.Spice.Netlist import SubCircuitFactory\n\nclass OneStageAmplifier(SubCircuitFactory):\n    NAME = 'OneStageAmplifier'\n    NODES = ('Vin', 'Vbias', 'Vout', 'VDD', 'GND')\n  \n    def __init__(self, nmos_width=50e-6, nmos_length=1e-6, load_resistance=10e3, \n                 input_capacitance=1e-12, output_capacitance=1e-12):\n        super().__init__()\n        # Define MOSFET model (level 1)\n        self.model('nmos_model', 'nmos', level=1, kp=100e-6, vto=0.5)\n    \n        # Topology\n        self.MOSFET('M1', 'Vout', 'Vbias', 'GND', 'GND', model='nmos_model', w=nmos_width, l=nmos_length)\n        self.R('R1', 'VDD', 'Vout', load_resistance)\n        \n        # Coupling capacitors\n        if input_capacitance > 0:\n            self.C('C1', 'Vin', 'Vbias', input_capacitance)\n        if output_capacitance > 0:\n            self.C('C2', 'Vout', 'GND', output_capacitance)",
    "testcode": [
        "import sys\nfrom pathlib import Path\nroot_dir = str(Path(__file__).parent.parent)\nsys.path.append(root_dir)\n\nfrom modules.OneStageAmplifier import OneStageAmplifier\nfrom PySpice.Spice.Netlist import Circuit\nfrom PySpice.Unit import *\n\ndef test_amplifier_dc_operating_point():\n    circuit = Circuit('Amplifier DC Test')\n    \n    # Setup power supply and bias\n    vdd_value = 5.0\n    vbias_value = 1.0  # Typical bias voltage\n    circuit.V('dd', 'VDD', circuit.gnd, vdd_value@u_V)\n    circuit.V('bias', 'Vbias', circuit.gnd, vbias_value@u_V)\n    \n    # Add amplifier subcircuit\n    circuit.subcircuit(OneStageAmplifier(\n        nmos_width=10e-6,\n        nmos_length=1e-6,\n        load_resistance=10@u_k\u03a9,\n        input_capacitance=1@u_uF,\n        output_capacitance=1@u_uF\n    ))\n    circuit.X('amp', 'OneStageAmplifier', 'Vin', 'Vbias', 'Vout', 'VDD', circuit.gnd)\n    \n    # Set input to 0V for DC test\n    circuit.V('in', 'Vin', circuit.gnd, 0@u_V)\n    \n    simulator = circuit.simulator(temperature=25, nominal_temperature=25)\n    analysis = simulator.operating_point()\n    \n    # Get output voltage\n    vout = analysis['Vout'].as_ndarray().item()\n    \n    # Expected output range (should be between VDD and ground)\n    min_expected = 0.1 * vdd_value\n    max_expected = 0.9 * vdd_value\n    \n    # Check if output is in expected range\n    if min_expected <= vout <= max_expected:\n        print(f\"Test_Passed: Vout = {vout:.3f}V is within expected range ({min_expected:.1f}V to {max_expected:.1f}V)\")\n        return True\n    else:\n        print(f\"Test_Failed: Vout = {vout:.3f}V is outside expected range ({min_expected:.1f}V to {max_expected:.1f}V)\")\n        return False\n\nif __name__ == \"__main__\":\n    test_amplifier_dc_operating_point()",
        "import sys\nfrom pathlib import Path\nroot_dir = str(Path(__file__).parent.parent)\nsys.path.append(root_dir)\n\nfrom modules.OneStageAmplifier import OneStageAmplifier\nfrom PySpice.Spice.Netlist import Circuit\nfrom PySpice.Unit import *\n\ndef test_amplifier_ac_gain():\n    circuit = Circuit('Amplifier AC Gain Test')\n    \n    # Setup power supply and bias\n    vdd_value = 5.0\n    vbias_value = 1.0\n    circuit.V('dd', 'VDD', circuit.gnd, vdd_value@u_V)\n    circuit.V('bias', 'Vbias', circuit.gnd, vbias_value@u_V)\n    \n    # Add amplifier subcircuit\n    rload = 10@u_k\u03a9\n    circuit.subcircuit(OneStageAmplifier(\n        nmos_width=10e-6,\n        nmos_length=1e-6,\n        load_resistance=rload,\n        input_capacitance=1@u_uF,\n        output_capacitance=1@u_uF\n    ))\n    circuit.X('amp', 'OneStageAmplifier', 'Vin', 'Vbias', 'Vout', 'VDD', circuit.gnd)\n    \n    # Setup AC input signal (1mV amplitude)\n    circuit.VSIN('in', 'Vin', circuit.gnd, amplitude=1@u_mV, frequency=1@u_kHz)\n    \n    simulator = circuit.simulator(temperature=25, nominal_temperature=25)\n    \n    # Run AC analysis at signal frequency\n    analysis = simulator.ac(frequency=1@u_kHz, variation='dec', number_of_points=1,  start_frequency=1@u_kHz, stop_frequency=1@u_kHz)\n    \n    # Calculate gain (Vout/Vin)\n    vout = analysis['Vout'].as_ndarray().item()\n    vin = analysis['Vin'].as_ndarray().item()\n    gain = vout / vin\n    \n    # Expected gain range (approximate)\n    expected_min_gain = -20  # Conservative estimate\n    expected_max_gain = -5   # Conservative estimate\n    \n    if expected_min_gain <= gain <= expected_max_gain:\n        print(f\"Test_Passed: Gain = {gain:.1f} is within expected range ({expected_min_gain} to {expected_max_gain})\")\n        return True\n    else:\n        print(f\"Test_Failed: Gain = {gain:.1f} is outside expected range ({expected_min_gain} to {expected_max_gain})\")\n        return False\n\nif __name__ == \"__main__\":\n    test_amplifier_ac_gain()",
        "import sys\nfrom pathlib import Path\nroot_dir = str(Path(__file__).parent.parent)\nsys.path.append(root_dir)\n\nfrom modules.OneStageAmplifier import OneStageAmplifier\nfrom PySpice.Spice.Netlist import Circuit\nfrom PySpice.Unit import *\n\ndef test_amplifier_frequency_response():\n    circuit = Circuit('Amplifier Frequency Response Test')\n    \n    # Setup power supply and bias\n    vdd_value = 5.0\n    vbias_value = 1.0\n    circuit.V('dd', 'VDD', circuit.gnd, vdd_value@u_V)\n    circuit.V('bias', 'Vbias', circuit.gnd, vbias_value@u_V)\n    \n    # Add amplifier subcircuit with known capacitors\n    cin = 1@u_uF\n    cout = 1@u_uF\n    rload = 10@u_k\u03a9\n    circuit.subcircuit(OneStageAmplifier(\n        nmos_width=10e-6,\n        nmos_length=1e-6,\n        load_resistance=rload,\n        input_capacitance=cin,\n        output_capacitance=cout\n    ))\n    circuit.X('amp', 'OneStageAmplifier', 'Vin', 'Vbias', 'Vout', 'VDD', circuit.gnd)\n    \n    # AC input (1mV)\n    circuit.V('in', 'Vin', circuit.gnd, 0@u_V)\n    circuit.Sinusoidal('in', 'Vin', circuit.gnd, amplitude=1@u_mV)\n    \n    simulator = circuit.simulator(temperature=25, nominal_temperature=25)\n    \n    # Run AC analysis over wide frequency range\n    analysis = simulator.ac(start_frequency=1@u_Hz, stop_frequency=100@u_MHz, number_of_points=100, variation='dec')\n    \n    # Find mid-band gain (should be around 1kHz)\n    midband_idx = 30  # Approximately 1kHz in our sweep\n    midband_gain = abs(analysis['Vout'][midband_idx] / abs(analysis['Vin'][midband_idx])\n    \n    # Find -3dB points\n    low_freq = None\n    high_freq = None\n    \n    for i in range(len(analysis.frequency)):\n        current_gain = abs(analysis['Vout'][i] / analysis['Vin'][i])\n        if current_gain < 0.707 * midband_gain:\n            if analysis.frequency[i] < 1@u_kHz:\n                low_freq = analysis.frequency[i]\n            else:\n                high_freq = analysis.frequency[i]\n            break\n    \n    # Check if frequency response meets expectations\n    test_passed = True\n    \n    # Check low frequency cutoff (should be below 100Hz with 1uF caps)\n    if low_freq is not None and low_freq > 100:\n        test_passed = False\n        print(f\"Test_Failed: Low frequency cutoff {low_freq:.1f}Hz is too high (expected <100Hz)\")\n    \n    # Check high frequency cutoff (should be above 1MHz)\n    if high_freq is not None and high_freq < 1@u_MHz:\n        test_passed = False\n        print(f\"Test_Failed: High frequency cutoff {high_freq/1e6:.2f}MHz is too low (expected >1MHz)\")\n    \n    if test_passed:\n        print(\"Test_Passed: Frequency response meets expectations\")\n        print(f\"  Low cutoff: {'<100Hz' if low_freq is None else f'{low_freq:.1f}Hz'}\")\n        print(f\"  High cutoff: {'>1MHz' if high_freq is None else f'{high_freq/1e6:.2f}MHz'}\")\n    \n    return test_passed\n\nif __name__ == \"__main__\":\n    test_amplifier_frequency_response()",
        "import sys\nfrom pathlib import Path\nroot_dir = str(Path(__file__).parent.parent)\nsys.path.append(root_dir)\n\nfrom modules.OneStageAmplifier import OneStageAmplifier\nfrom PySpice.Spice.Netlist import Circuit\nfrom PySpice.Unit import *\n\ndef test_amplifier_impedances():\n    circuit = Circuit('Amplifier Impedance Test')\n    \n    # Setup power supply and bias\n    vdd_value = 5.0\n    vbias_value = 1.0\n    circuit.V('dd', 'VDD', circuit.gnd, vdd_value@u_V)\n    circuit.V('bias', 'Vbias', circuit.gnd, vbias_value@u_V)\n    \n    # Add amplifier subcircuit\n    rload = 10@u_k\u03a9\n    circuit.subcircuit(OneStageAmplifier(\n        nmos_width=10e-6,\n        nmos_length=1e-6,\n        load_resistance=rload,\n        input_capacitance=1@u_uF,\n        output_capacitance=1@u_uF\n    ))\n    \n    # Test input impedance by adding series resistor\n    rtest_in = 1@u_M\u03a9\n    circuit.R('test_in', 'Vin_test', 'Vin', rtest_in)\n    circuit.X('amp', 'OneStageAmplifier', 'Vin', 'Vbias', 'Vout', 'VDD', circuit.gnd)\n    \n    # Test output impedance by adding load resistor\n    rtest_out = rload  # Same as amplifier's load for testing\n    circuit.R('test_out', 'Vout', circuit.gnd, rtest_out)\n    \n    # AC input signal (1mV)\n    circuit.VSIN('in', 'Vin_test', circuit.gnd, amplitude=1@u_mV, frequency=1@u_kHz)\n    \n    simulator = circuit.simulator(temperature=25, nominal_temperature=25)\n    analysis = simulator.ac(frequency=1@u_kHz, variation='dec', number_of_points=1, start_frequency=1@u_kHz, stop_frequency=1@u_kHz)\n    \n    # Calculate input impedance\n    vin_test = analysis['Vin_test'].as_ndarray().item()\n    vin = analysis['Vin'].as_ndarray().item()\n    zin = (vin / (vin_test - vin)) * rtest_in\n    \n    # Calculate output impedance\n    vout_open = analysis['Vout'].as_ndarray().item()  # Without Rtest_out\n    # Need to run another simulation without Rtest_out to get open-circuit voltage\n    circuit.remove_element('Rtest_out')\n    analysis_open = simulator.ac(frequency=1@u_kHz, variation='dec', number_of_points=1, start_frequency=1@u_kHz, stop_frequency=1@u_kHz)\n    vout_open = analysis_open['Vout'].as_ndarray().item()\n    \n    vout_loaded = analysis['Vout'].as_ndarray().item()\n    zout = ((vout_open / vout_loaded) - 1) * rtest_out\n    \n    # Check results\n    test_passed = True\n    \n    # Input impedance should be >> 1M\u03a9 at 1kHz (dominated by Cin)\n    if zin < 100@u_k\u03a9:\n        test_passed = False\n        print(f\"Test_Failed: Input impedance {zin/1e6:.2f}M\u03a9 is too low (expected >>100k\u03a9)\")\n    \n    # Output impedance should be close to Rload\n    zout_error = abs(zout - rload) / rload\n    if zout_error > 0.2:  # 20% tolerance\n        test_passed = False\n        print(f\"Test_Failed: Output impedance {zout/1e3:.1f}k\u03a9 differs from Rload {rload/1e3:.1f}k\u03a9 by more than 20%\")\n    \n    if test_passed:\n        print(\"Test_Passed: Impedances meet expectations\")\n        print(f\"  Input impedance: {zin/1e6:.2f}M\u03a9\")\n        print(f\"  Output impedance: {zout/1e3:.1f}k\u03a9 (Rload = {rload/1e3:.1f}k\u03a9)\")\n    \n    return test_passed\n\nif __name__ == \"__main__\":\n    test_amplifier_impedances()"
    ],
    "testDescription": [
        "DC Operating Point Test: Verify the amplifier's DC biasing conditions. Set Vin to 0V and check if the output voltage is within the expected range (typically between VDD and ground). This ensures the transistor is properly biased in the saturation region.",
        "AC Small Signal Gain Test: Verify the amplifier's voltage gain by applying a small AC signal (1mV) and measuring the output. The gain should be approximately -gm*Rload (negative sign indicates inversion). Check if the gain matches expectations based on component values.",
        "Frequency Response Test: Verify the amplifier's bandwidth by performing an AC sweep. Check that the low-frequency cutoff is determined by the coupling capacitors and the high-frequency cutoff is determined by transistor parasitics and load resistance.",
        "Input/Output Impedance Test: Verify the input impedance is high (dominated by gate capacitance) and output impedance is approximately equal to the load resistance. This is done by measuring voltage division with known test resistors."
    ]
}